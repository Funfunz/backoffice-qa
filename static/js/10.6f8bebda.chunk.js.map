{"version":3,"sources":["views/playground/index.tsx","hooks/useEntry.ts"],"names":["Playground","entities","useEntities","entity","useEntity","useEntry","pk","entry","setEntry","saveEntry","newEntry","setNewEntry","addEntry","JSON","stringify","mapFieldComponents","map","field","index","props","label","onChange","event","target","name","value","onClick","memo","filter","fields","initialData","useState","fetchedEntry","setFetchedEntry","modifiedEntry","setModifiedEntry","loading","setLoading","error","setError","getPk","oldArgs","setNewArgs","hasNewArgs","useCallback","getName","entryEquals","useEffect","getEntryData","then","data","filterMatch","catch","saveEntryData","entryDiff"],"mappings":"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","file":"static/js/10.6f8bebda.chunk.js","sourcesContent":["import React, { FC, memo } from 'react'\nimport { useEntities } from 'hooks/useEntities'\nimport { useEntity } from 'hooks/useEntity'\nimport { useEntry } from 'hooks/useEntry'\nimport { mapFieldComponents } from 'utils/fields'\n\nconst Playground: FC = () => {\n  const entities = useEntities()\n  const entity = useEntity('products')\n  const { entry, setEntry, saveEntry } = useEntry({entity, pk: 1 })\n  const { entry: newEntry, setEntry: setNewEntry, saveEntry: addEntry } = useEntry({ entity })\n\n  return (\n    <div>\n      <h1>Entities</h1>\n      <pre>\n        {JSON.stringify(entities, null, 4)}\n      </pre>\n      <h1>Entity</h1>\n      <pre>\n        {JSON.stringify(entity, null, 4)}\n      </pre>\n      <h1>User entry</h1>\n      <pre>\n        {JSON.stringify(entry, null, 4)}\n      </pre>\n      <h1>Update entry</h1>\n      {mapFieldComponents(entity).map((field, index) =>\n        // match `field.component` to correct React component\n        // pass `field.props` to that component\n        <div key={index}>\n          <label>{field.props.label}</label><br />\n          <input \n            {...field.props} \n            onChange={(event) => setEntry((entry) => ({...entry, [event.target.name]: event.target.value}))} \n            value={entry[field.props.name] as string || ''} />\n        </div>\n        \n      )}\n      <button onClick={saveEntry}>Save</button>\n      <h1>Add entry</h1>\n      {mapFieldComponents(entity).map((field, index) =>\n        // match `field.component` to correct React component\n        // pass `field.props` to that component\n        <div key={index}>\n          <label>{field.props.label}</label><br />\n          <input \n            {...field.props} \n            onChange={(event) => setNewEntry((entry) => ({...newEntry, [event.target.name]: event.target.value}))} \n            value={newEntry[field.props.name] as string || ''} />\n        </div>\n        \n      )}\n      <button onClick={addEntry}>Add</button>\n    </div>\n  )\n}\n\nexport default memo(Playground)","import { useCallback, useEffect, useState } from 'react'\nimport { IFields } from '../services/graphql'\nimport Entity from '../services/entity'\nimport { \n  entryDiff,\n  entryEquals,\n  filterMatch,\n  getEntryData,\n  IEntryData,\n  IFilter,\n  saveEntryData,\n} from '../services/entry'\n\nexport interface IUseEntryArgs {\n  entity?: Entity\n  filter?: IFilter\n  pk?: string | number\n  fields?: IFields\n  initialData?: IEntryData\n}\nexport interface IUseEntry {\n  entry: IEntryData,\n  setEntry: React.Dispatch<React.SetStateAction<IEntryData>>,\n  saveEntry: () => Promise<void>,\n  error: boolean\n}\n\n/* Get entry data based on a filter */\nexport function useEntry({\n  entity,\n  filter,\n  pk,\n  fields,\n  initialData = {},\n}: IUseEntryArgs): IUseEntry {\n\n  const [fetchedEntry, setFetchedEntry] = useState<IEntryData>(initialData)\n  const [modifiedEntry, setModifiedEntry] = useState<IEntryData>(initialData)\n\n  const [loading, setLoading] = useState(false)\n  const [error, setError] = useState(false)\n\n  if (!filter) {\n    filter = { [entity?.getPk() as string]: pk }\n  }\n  \n  const [oldArgs, setNewArgs] = useState<{ entity?: string, filter?: IFilter }>({})\n\n  const hasNewArgs = useCallback(() => {\n    if (\n      entity?.getName() !== oldArgs.entity ||\n      !entryEquals(filter, oldArgs.filter)\n    ) {\n      setNewArgs({ entity: entity?.getName(), filter })\n      return true\n    }\n    return false\n  }, [entity, oldArgs, filter])\n\n  useEffect(() => {\n    if (\n      hasNewArgs() && \n      !loading && !error &&\n      !entryEquals(fetchedEntry, filter) &&\n      entity\n    ) {\n      setLoading(true)\n      getEntryData(entity, filter, fields).then((data) => {\n        setLoading(false)\n        if (data && filterMatch(data, filter as IFilter)) {\n          setFetchedEntry(data)\n          setModifiedEntry(data)\n          setError(false)\n        } else {\n          setError(true)\n        }\n      }).catch(() => {\n        setLoading(false)\n        setError(true)\n      })\n    } \n  }, [entity, loading, filter, error, fetchedEntry, hasNewArgs, fields])\n\n  const saveEntry = useCallback(() => {\n    return saveEntryData(\n      entity as Entity,\n      entryDiff(fetchedEntry, modifiedEntry),\n      filter,\n    )\n  }, [entity, filter, modifiedEntry, fetchedEntry])\n\n  return {\n    entry: modifiedEntry,\n    setEntry: setModifiedEntry,\n    saveEntry,\n    error,\n  }\n}"],"sourceRoot":""}